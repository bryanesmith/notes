# JSON Web Token (JWT)

Pronounced "jot"

Open standard (**RFC 7519**) for authorization 

Often paired with OAuth for Single Sign On

The authorization token is generated by Identity Provided (**IdP**) for Customer Identity and Access Management (**CIAM**)

Generally included in "Authorization" header: `Authorization: Bearer <token>`

Contains header, payload, signature base64 encoded and separated by a dot (.)

The header typically ocontains `"typ": "JWT"` and `"alg"` (usually HMAC SHA256 or `RSA`) E.g.,

```json
{
	"alg": "HS256",
	"typ": "JWT" 
}
```

The payload contains **claims**, including:
    1. **registered claims**: recommended (but not required) claims; e.g., iss, exp, aud, etc
    2. **public claims**: claims that are either registered in a registry or expressed as URIs
    3. **private claims**: custom claims 
 

E.g.,
```json
{
	"sub": "1234567890",
	"name": "John Doe",
	"admin": true
}
```

Authorization tokens expire in minutes, often paired with refresh tokens

Pros: 

    1. portable
    2. efficient (less chatty, e.g., less db calls)
    3. compact
    4. verifiable (digitally signed)
    5. stateless (not tracked in server)
    6. CORS compatible (unlike cookies, which must be configured)
    7. JSON naturally maps to programming objects

Cons:

    1. hard to revoke (e.g., log out, block or terminate account)
    2. can’t be too big (some servers have 8 KB header limits)

Best Practices:

    1. use HTTPS to avoid MITM attacks
    2. always validate
    3. Use asymetric encryption (e.g., RSA)
    4. avoid HMAC (symmetic, too efficient)
    5. don’t accept `"alg": "none"`
    6. use short-lived access tokens

Alternatives:

    1. Sessions (e.g., login, server returns session ID as cookie)
    2. Simple Web Tokens (SWT, only symmetrically signed)
    3. SAML (XML, so verbose; compex)